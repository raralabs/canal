{
package node

import (
        "github.com/raralabs/canal/network/builder/utils"
        "github.com/raralabs/canal/transforms/event/poll"
)

type Instruction struct {
        Type   utils.JobType     // Type of the job
        Name   string            // Name of the job
        Desc   string            // Description of the job
        Group  []string
        Params poll.Event
}

type Creation struct {
        Incomings []interface{}
}

var jobMap = map[string]utils.JobType {
        "filter": utils.FILTER,
        "branch": utils.BRANCH,
        "lua": utils.LUA,
        "count": utils.COUNT,
        "pass": utils.PASS,

        "stdout": utils.STDOUT,
        "blackhole": utils.BLACKHOLE,
}

}

Node <- _ name:Variable _ "@" job:JobType param:InitialParam group:(GroupBy)? _ desc:JobDescription? {
        nodeName := name

        jobType, ok := job.(utils.JobType)
        if !ok {
                log.Fatalln("The requested job is not yet implemented")
        }

        var filt poll.Event
        if param != nil {
                filt, ok = param.(poll.Event)
                if !ok {
                        log.Fatalln("The requested parameter is not supported")
                }
        }

        jobName := ""
        jobParams := ""
        if desc != nil {
                d := utils.ToIfaceSlice(desc)
                jobName, _ = d[0].(string)
                jobParams, _ = d[1].(string)
        }

        var groupBy []string
        if group != nil {
                for _, v := range utils.ToIfaceSlice(group) {
                        if str, ok := utils.TryString(v); ok {
                                groupBy = append(groupBy, str)
                        }
                }
        }

        return []interface{}{nodeName, Instruction{Type: jobType, Name: jobName,
                Group: groupBy, Desc: jobParams, Params: filt}}, nil
} /
_ name:Variable _ "@" _ "from:" incomings:(NodeJob)+ {
        return []interface{}{name, Creation{Incomings: utils.ToIfaceSlice(incomings)}}, nil
}

InitialParam <- "(" filt:MultiFilter? ")" {
        return filt, nil
}

GroupBy <- _ "by " _ first:Variable rest:("," _ Variable)* _ {
        var group []interface{}
        group = append(group, first)

        restG := utils.ToIfaceSlice(rest)
        for _, v := range restG {
                gr := utils.ToIfaceSlice(v)
                group = append(group, gr[2])
        }

        return group, nil
}

NodeJob <- _ nodeName:Variable "." jobName:Variable {
        return []interface{}{nodeName, jobName}, nil
}

JobType <- jobType:(ProcessorType / SinkType) {
        switch s := jobType.(type) {
        case []uint8:
                return jobMap[string(s)], nil
        case string:
                return jobMap[s], nil
        }
        return nil, errors.New("Unknown JobType")
}

ProcessorType <- "filter" / "branch" / "lua" / "count" / "pass" {
        return string(c.text), nil
}

SinkType <- "stdout" / "blackhole" {
        return string(c.text), nil
}

JobDescription <- iden:Variable param:JobParameters? {
        nameParam := []interface{}{iden, param}
        return nameParam, nil
}

JobParameters <- ":" _ params:AnySequence {
        return params, nil
}

// A MultiFilter defines a filter that consists of either a single factor or
// multiple factors separated by secondary operators.
MultiFilter <- first:FilterFactor rest:(_ op:SecondaryFilterOperator _ f2:FilterFactor)* {

        if filterDesc, ok := utils.TryString(string(c.text)); ok {

                filt, err := filter.Parse("", []byte(filterDesc))
                if err != nil {
                        log.Fatalf("Could not parse filter: %v\n", err)
                }

                if f, ok := filt.(filter.Filter); ok {
                        eventFilter := func(m map[string]interface{}) bool {
                                out, _ := f(m)
                                return out
                        }
                        return poll.NewFilterEvent(eventFilter), nil
                }
        }

        return nil, errors.New("Could not parse filter!!")
}

// A Factor is either a primary filter or a multi filter enclosed by parenthesis
FilterFactor <- '(' sf:MultiFilter ')' {
    return sf, nil
} / pf:PrimaryFilter {
    return pf, nil
}

SecondaryFilterOperator <- "and" / "or" {
        return string(c.text), nil
}


// A PrimaryFilter defines a filter that checks if the value defined by the
// variable is according to the primary operator.
PrimaryFilter <- name:Expr _ op:PrimaryFilterOperator _ value:(Value / String / String_Type2) {
        return string(c.text), nil
}

PrimaryFilterOperator <- "==" / "!=" / "<" / ">" / "<=" / ">=" {
        return string(c.text), nil
}

Expr <- Variable ( _ ("%" / "-" / "+" / "*" / "/") _ (Variable / Number))* {
        return string(c.text), nil
} / "'" expr:Expr "'" {
        return expr, nil
}

String_Type2 <- "'" w1:Word rest:( _ Word )* "'" {
        var str strings.Builder

        if w, ok := w1.(string); ok {

                str.WriteString(w)
                rst := utils.ToIfaceSlice(rest)

                for _, v := range rst {
                        rstStr := utils.ToIfaceSlice(v)
                        if len(rstStr) == 2 {
                                if wrd, ok := rstStr[1].(string); ok {
                                        str.WriteString(" ")
                                        str.WriteString(wrd)
                                }
                        }
                }
        }
        s := str.String()
        
        return utils.GetStringValue(s), nil
}

String <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
        c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
        str,_ := strconv.Unquote(string(c.text))

        return utils.GetStringValue(str), nil
}

Value <- val:(Number / Word) {
        return val, nil
}

Variable <- Letter (Integer / Letter/ "_")* {
        return string(c.text), nil
}

AnySequence <- (Symbol / Letter / DecimalDigit / OneWhiteSpace)+ {
        return string(c.text), nil
}

Symbol <-  "|" / " " / "!" / "#" / "$" / "%" / "&" / "(" / ")" / "*" / "+" /
        "," / "-" / "." / "/" / ":" / ";" / ">" / "=" / "<" / "?" / "@" / "[" /
        "\\" / "]" / "^" / "_" / "`" / "{" / "}" / "~" / "'"


Word <- (Letter / "_")+ {
        return string(c.text), nil
}

Letter <- [a-z] / [A-Z]

Number <- '-'? Integer {
        return strconv.ParseInt(string(c.text), 10, 64)
}

Integer <- '0' / NonZeroDecimalDigit DecimalDigit*

DecimalDigit <- [0-9]

NonZeroDecimalDigit <- [1-9]

_ "whitespace" <- [ \t\r\n]*

OneWhiteSpace <- [ \t\r\n]

EOF <- !.
