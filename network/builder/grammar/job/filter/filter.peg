{
package filter

import (
	"github.com/Knetic/govaluate"
    "github.com/n-is/canal/network/builder/utils"
)

// A Filter represents a function that takes valueMap of the message and
// performs checks if the map conforms to some rule.
type Filter func(v map[string]interface{}) (bool, error)


// A secondaryOperatorMap holds the mapping of secondary operators like or, and.
var secondaryOperatorMap = map[string]func(l, r bool) (bool, error) {
        "or": func(l, r bool) (bool, error) {
                return l || r, nil
        },
        "and": func(l, r bool) (bool, error) {
                return l && r, nil
        },
}

// newPrimaryFilter returns a filter defined by op.
func newPrimaryFilter(name string, op , val interface{}) Filter {
    operator := ""
    switch op := op.(type) {
    case []uint8:
            operator = string(op)
    case string:
            operator = op
    }

    condition := fmt.Sprintf("%s %s %v", name, operator, val)

	expression, err := govaluate.NewEvaluableExpression(condition)
	if err != nil {
		panic(err)
	}

    filter := func(valMap map[string]interface{}) (bool, error) {
    ret := false

    result, err := expression.Evaluate(valMap)
    if err != nil {
        return false, err
    }

    rbool, ok := result.(bool)
    if !ok {
        return false, errors.New("non boolean result in filter condition")
    } else {
        ret = rbool
    }

            return ret, nil
    }

    return filter
}

// newSecondaryFilter returns a filter defined by rest recursively.
func newSecondaryFilter(first, rest interface{}) Filter {

        filter := func(valMap map[string]interface{}) (bool, error) {

                if valMap == nil {
                        return false, nil
                }
                
                l := first.(Filter)
                outl, _ := l(valMap)

                restSl := utils.ToIfaceSlice(rest)
                for _, v := range restSl {
                        restExpr := utils.ToIfaceSlice(v)
                        r := restExpr[3].(Filter)
                        op := restExpr[1]
                        operator := ""
                        switch op := op.(type) {
                        case []uint8:
                                operator = string(op)
                        case string:
                                operator = op
                        }

                        outr, _ := r(valMap)
                        outl, _ = secondaryOperatorMap[operator](outl, outr)
                }
                return outl, nil
        }

        return filter
}

}


// A MultiFilter defines a filter that consists of either a single factor or
// multiple factors separated by secondary operators.
MultiFilter <- first:Factor rest:(_ op:SecondaryFilterOperator _ f2:Factor)* {
        return newSecondaryFilter(first, rest), nil
}

// A Factor is either a primary filter or a multi filter enclosed by parenthesis
Factor <- '(' sf:MultiFilter ')' {
    return sf, nil
} / pf:PrimaryFilter {
    return pf, nil
}

SecondaryFilterOperator <- "and" / "or" {
        return string(c.text), nil
}


// A PrimaryFilter defines a filter that checks if the value defined by the
// variable is according to the primary operator.
PrimaryFilter <- name:Expr _ op:PrimaryFilterOperator _ value:(Value / String / String_Type2) _ {
        return newPrimaryFilter(name.(string), op, value), nil
}

PrimaryFilterOperator <- "==" / "!=" / "<" / ">" / "<=" / ">=" {
        return string(c.text), nil
}

Expr <- Variable ( _ ("%" / "-" / "+" / "*" / "/") _ (Variable / Number))* {
        return string(c.text), nil
} / "'" expr:Expr "'" {
        return expr, nil
}

Value <- val:(Number / Word) {
        return val, nil
}

Variable <- Letter (Integer / Letter/ "_")* {
        return string(c.text), nil
}

String_Type2 <- "'" w1:Word rest:( _ Word )* "'" {
        var str strings.Builder

        if w, ok := w1.(string); ok {

                str.WriteString(w)
                rst := utils.ToIfaceSlice(rest)

                for _, v := range rst {
                        rstStr := utils.ToIfaceSlice(v)
                        if len(rstStr) == 2 {
                                if wrd, ok := rstStr[1].(string); ok {
                                        str.WriteString(" ")
                                        str.WriteString(wrd)
                                }
                        }
                }
        }
        s := str.String()
        
        return utils.GetStringValue(s), nil
}

String <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
        c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
        str,_ := strconv.Unquote(string(c.text))

        return utils.GetStringValue(str), nil
}

EscapedChar <- [\x00-\x1f"\\]

EscapeSequence <- SingleCharEscape

SingleCharEscape <- ["\\/bfnrt]

Word <- (Letter / "_")+ {
        return string(c.text), nil
}

Letter <- [a-z] / [A-Z]

Number <- '-'? Integer {
        return strconv.ParseInt(string(c.text), 10, 64)
}

Integer <- '0' / NonZeroDecimalDigit DecimalDigit*

DecimalDigit <- [0-9]

NonZeroDecimalDigit <- [1-9]

_ "whitespace" <- [ \t\r\n]*

OneWhiteSpace <- [ \t\r\n]

EOF <- !.
