{
package count

import (
        "github.com/raralabs/canal/network/builder/utils"
        "github.com/raralabs/canal/network/builder/grammar/job/filter"
        "github.com/raralabs/canal/transforms/event/poll"
)

var operatorMap = map[string]string {
        "||": "or",
        "&&": "and",
}

}

Counter <- _ first:CounterFactor rest:(_ Operators _ CounterFactor)* {

        event := first.(poll.Event)
        
        restSl := utils.ToIfaceSlice(rest)

        for _, v := range restSl {
                restExpr := utils.ToIfaceSlice(v)
                r := restExpr[3].(poll.Event)
                op := restExpr[1]
                if operator, ok := utils.TryString(op); ok {
                        lastEvent := event
                        event = poll.NewCompositeEvent(operatorMap[operator], r, lastEvent)
                }
        }

        return event, nil
}

CounterFactor <- '(' cnt:Counter ')' {
        return cnt, nil
} / ce:CounterEvent {
        return ce, nil
}

CounterEvent <- IntervalDesc / MultiFilter

Operators <- "||" / "&&"

IntervalDesc <- _ "interval" _ "=" _ val:Number unit:("s" / "m" / "h") {
        v := val.(int64)
        u, _ := utils.TryString(unit)

        var interval time.Duration

        switch u {
        case "s":
                interval = time.Duration(v) * time.Second
        case "m":
                interval = time.Duration(60 * v) * time.Second
        case "h":
                interval = time.Duration(60 * 60 * v) * time.Second
        default:
                return nil, errors.New("Non-supported time unit.")
        }

        return poll.NewTimerEvent(interval), nil
}

// A MultiFilter defines a filter that consists of either a single factor or
// multiple factors separated by secondary operators.
MultiFilter <- first:FilterFactor rest:(_ op:SecondaryFilterOperator _ f2:FilterFactor)* {

        if filterDesc, ok := utils.TryString(string(c.text)); ok {

                filt, err := filter.Parse("", []byte(filterDesc))
                if err != nil {
                        log.Fatalf("Could not parse filter: %v\n", err)
                }

                if f, ok := filt.(filter.Filter); ok {
                        eventFilter := func(m map[string]interface{}) bool {
                                out, _ := f(m)
                                return out
                        }
                        return poll.NewFilterEvent(eventFilter), nil
                }
        }

        return nil, errors.New("Could not parse filter!!")
}

// A Factor is either a primary filter or a multi filter enclosed by parenthesis
FilterFactor <- '(' sf:MultiFilter ')' {
    return sf, nil
} / pf:PrimaryFilter {
    return pf, nil
}

SecondaryFilterOperator <- "and" / "or" {
        return string(c.text), nil
}


// A PrimaryFilter defines a filter that checks if the value defined by the
// variable is according to the primary operator.
PrimaryFilter <- name:Expr _ op:PrimaryFilterOperator _ value:(Value / String / String_Type2) {
        return string(c.text), nil
}

PrimaryFilterOperator <- "==" / "!=" / "<" / ">" / "<=" / ">=" {
        return string(c.text), nil
}

Expr <- Variable ( _ ("%" / "-" / "+" / "*" / "/") _ (Variable / Number))* {
        return string(c.text), nil
} / "'" expr:Expr "'" {
        return expr, nil
}

Value <- val:(Number / Word) {
        return val, nil
}

Variable <- Letter (Integer / Letter/ "_")* {
        return string(c.text), nil
}

String_Type2 <- "'" w1:Word rest:( _ Word )* "'" {
        var str strings.Builder

        if w, ok := w1.(string); ok {

                str.WriteString(w)
                rst := utils.ToIfaceSlice(rest)

                for _, v := range rst {
                        rstStr := utils.ToIfaceSlice(v)
                        if len(rstStr) == 2 {
                                if wrd, ok := rstStr[1].(string); ok {
                                        str.WriteString(" ")
                                        str.WriteString(wrd)
                                }
                        }
                }
        }
        s := str.String()
        
        return utils.GetStringValue(s), nil
}

String <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
        c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
        str,_ := strconv.Unquote(string(c.text))

        return utils.GetStringValue(str), nil
}

EscapedChar <- [\x00-\x1f"\\]

EscapeSequence <- SingleCharEscape

SingleCharEscape <- ["\\/bfnrt]

Word <- (Letter / "_")+ {
        return string(c.text), nil
}

Letter <- [a-z] / [A-Z]

Number <- '-'? Integer {
        return strconv.ParseInt(string(c.text), 10, 64)
}

Integer <- '0' / NonZeroDecimalDigit DecimalDigit*

DecimalDigit <- [0-9]

NonZeroDecimalDigit <- [1-9]

_ "whitespace" <- [ \t\r\n]*

OneWhiteSpace <- [ \t\r\n]

EOF <- !.
