{
package idiom
}


// Main Grammar
Main <- id:(NodeCreatorG / NodeJobG) {
        return id, nil
}

// Basic Grammar

Expr <- Variable ( _ ("%" / "-" / "+" / "*" / "/") _ (Variable / Number))* {
        return string(c.text), nil
}

Value <- val:(Number / Word / String_Type1 / String_Type2) {
        return val, nil
}

Variable <- Letter (Integer / Letter/ "_")* {
        return string(c.text), nil
}

String_Type2 <- "'" w1:Word rest:( _ Word )* "'" {
        var str strings.Builder

        if w, ok := w1.(string); ok {

                str.WriteString(w)
                rst := utils.ToIfaceSlice(rest)

                for _, v := range rst {
                        rstStr := utils.ToIfaceSlice(v)
                        if len(rstStr) == 2 {
                                if wrd, ok := rstStr[1].(string); ok {
                                        str.WriteString(" ")
                                        str.WriteString(wrd)
                                }
                        }
                }
        }
        s := str.String()
        
        return utils.GetStringValue(s), nil
}

String_Type1 <- '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
        c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
        str,_ := strconv.Unquote(string(c.text))

        return utils.GetStringValue(str), nil
}

EscapedChar <- [\x00-\x1f"\\]

EscapeSequence <- SingleCharEscape

SingleCharEscape <- ["\\/bfnrt]

Word <- (Letter / "_")+ {
        return string(c.text), nil
}

Letter <- [a-z] / [A-Z]

Number <- '-'? Integer {
        return strconv.ParseInt(string(c.text), 10, 64)
}

Integer <- '0' / NonZeroDecimalDigit DecimalDigit*

DecimalDigit <- [0-9]

NonZeroDecimalDigit <- [1-9]

_ "whitespace" <- [ \t\r\n]*

OneWhiteSpace <- [ \t\r\n]

EOF <- !.


// Node Creation Grammar

NodeCreatorG <- node:Variable " " froms:(FromNodeJob / GenesisFrom) {
        nodeName, _ := utils.TryString(node)
        fromNodes := froms.([]From)

        return NodeCreator{Name: nodeName, Froms: fromNodes}, nil
}

FromNodeJob <- "from(" _ first:SingleFrom _ rest:("," _ SingleFrom _ )* _ ")" {
        froms := []From {first.(From)}

        restSlice := utils.ToIfaceSlice(rest)
        for _, v := range restSlice {
                fr := utils.ToIfaceSlice(v)
                froms = append(froms, fr[2].(From))
        }

        return froms, nil
}

SingleFrom <- node:Variable "." job:Variable _ rest:("as " _ Variable)? {
        nodeName, _ := utils.TryString(node)
        jobName, _ := utils.TryString(job)

        if rest == nil {
                return From{Node: nodeName, Job: jobName, Alias: "", Genesis: false}, nil
        }

        restSlice := utils.ToIfaceSlice(rest)
        alias, _ := utils.TryString(restSlice[2])
        
        return From{Node: nodeName, Job: jobName, Alias: alias, Genesis: false}, nil
}

GenesisFrom <- "from()" {
        return []From{From{Node: "", Job: "", Alias: "", Genesis: true}}, nil
}


// NodeJob Addition Grammar

NodeJobG <- node:Variable "." jobN:Variable _ job:Job {
        nodeName, _ := utils.TryString(node)
        jobName, _ := utils.TryString(jobN)

        return NodeJob{NodeName: nodeName, JobName: jobName, Params: job}, nil
}

Job <- DoJobG / AggJobG / SinkJobG / JoinG

DoJobG <- job:(FilterDo / BranchDo) {
        return DoNodeJob{Function: job}, nil
}

AggJobG <- trg:TriggerGr _ job:AggJobs rest:("," _ AggJobs)* params:AggGroupBy? {
        jobSlices := utils.ToIfaceSlice(rest)
        jobs := []interface{}{job}

        for _, v := range jobSlices {
                j := utils.ToIfaceSlice(v)
                jobs = append(jobs, j[2])
        }

        ps, _ := params.([]string)
        trigger := trg.(poll.Event)

        return AggNodeJob{Trigger: trigger, Functions: jobs, GroupBy: ps}, nil
}

AggJobs <- CountAgg / MaxAgg / MinAgg

AggGroupBy <- _ "by " _ param:Variable rest:("," _ Variable)* {
        p1, _ := utils.TryString(param)
        params := []string{p1}

        restSlice := utils.ToIfaceSlice(rest)
        for _, v := range restSlice {
                ps := utils.ToIfaceSlice(v)
                p2, _ := utils.TryString(ps[2])
                params = append(params, p2)
        }

        return params, nil
}

SinkJobG <- StdOutG / BlackHoleG

StdOutG <- "stdout()" {
        return SinkJob{Type: "stdout"}, nil
}

BlackHoleG <- "blackhole()" {
        return SinkJob{Type: "blackhole"}, nil
}


// Filter Grammar

FilterDo <- "filter(" _ filt:FilterMulti _ ")" {
        if f, ok := filt.(Filter); ok {
                return f, nil
        }
        return nil, errors.New("Could not parse filter")
}

// A FilterMulti defines a filter that consists of either a single factor or
// multiple factors separated by secondary operators.
FilterMulti <- first:FilterFactor rest:(_ op:FilterSecOp _ f2:FilterFactor)* {
        return newSecondaryFilter(first, rest), nil
}

// A Factor is either a primary filter or a multi filter enclosed by parenthesis
FilterFactor <- '(' sf:FilterMulti ')' {
    return sf, nil
} / pf:FilterPrimary {
    return pf, nil
}

FilterSecOp <- "and" / "or" {
        return string(c.text), nil
}


// A FilterPrimary defines a filter that checks if the value defined by the
// variable is according to the primary operator.
FilterPrimary <- name:Expr _ op:FilterPriOp _ value:Value _ {
        return newPrimaryFilter(name.(string), op, value), nil
}

FilterPriOp <- "==" / "!=" / "<" / ">" / "<=" / ">=" {
        return string(c.text), nil
}


// Branch Grammar

BranchDo <- "branch(" _ br:BranchPrimary _ ")" {
        if branch, ok := utils.TryString(br); ok {
                return Branch{Condition: branch}, nil
        }
        return nil, errors.New("Could not decode branch syntax")
}

BranchPrimary <- name:Expr _ op:BranchPriOp _ value:(Value) {
        return string(c.text), nil
}

BranchPriOp <- FilterPriOp


// Aggregato Functions Grammar

CountAgg <- "count(" _ args:FilterMulti _ ")" _ "as" _ alias:Variable {
        if countName, ok := utils.TryString(alias); ok {
                return Count{Alias: countName, Filter: args.(Filter)}, nil
        }
        return nil, errors.New("Could not decode count syntax")
}

MaxAgg <- "max(" _ field:Variable _ "," _ args:FilterMulti _ ")" _ "as" _ alias:Variable {
        if countName, ok := utils.TryString(alias); ok {
                fld, _ := utils.TryString(field)
                return Max{Alias: countName, Field: fld, Filter: args.(Filter)}, nil
        }
        return nil, errors.New("Could not decode max syntax")
}

MinAgg <- "min(" _ field:Variable _ "," _ args:FilterMulti _ ")" _ "as" _ alias:Variable {
        if countName, ok := utils.TryString(alias); ok {
                fld, _ := utils.TryString(field)
                return Min{Alias: countName, Field: fld, Filter: args.(Filter)}, nil
        }
        return nil, errors.New("Could not decode min syntax")
}


// Join Grammar

JoinG <- trg:TriggerGr _ "join(" _ s1:Variable _ "," _ s2:Variable _ ")" _ jon:JoinOnG {
        
        trigger := trg.(poll.Event)

        st1, _ := utils.TryString(s1)
        st2, _ := utils.TryString(s2)

        filt := jon.(JoinFilter)

        return JoinNodeJob{Trigger: trigger, Streams: []string{st1, st2}, Filter: filt}, nil
}

JoinOnG <- _ "on " _ filt:JoinMFilterG {
        return filt, nil
}

JoinMFilterG <- first:JoinFilterFactor rest:(_ op:FilterSecOp _ f2:JoinFilterFactor)* {
        return newJoinSecFilter(first, rest), nil
}

// A Factor is either a primary filter or a multi filter enclosed by parenthesis
JoinFilterFactor <- '(' sf:JoinMFilterG ')' {
    return sf, nil
} / pf:JoinPFilterG {
    return pf, nil
}

JoinPFilterG <- first:JoinValueG _ op:FilterPriOp _ val:(JoinValueG / Value) {
        return newJoinPriFilter(first, op, val), nil
}

JoinValueG <- stream:Variable "." col:Variable {
        strm, _ := utils.TryString(stream)
        fld, _ := utils.TryString(col)

        return JoinValue{Stream: strm, Field: fld}, nil
}


// Trigger Grammar

TriggerGr <- _ "@Trigger(" _ trg:TriggerG _ ")" {
        return trg, nil
}

TriggerG <- _ first:TriggerFactor rest:(_ TriggerOperators _ TriggerFactor)* {

        event := first.(poll.Event)
        
        restSl := utils.ToIfaceSlice(rest)

        for _, v := range restSl {
                restExpr := utils.ToIfaceSlice(v)
                r := restExpr[3].(poll.Event)
                op := restExpr[1]
                if operator, ok := utils.TryString(op); ok {
                        lastEvent := event
                        event = poll.NewCompositeEvent(triggerOperatorMap[operator], r, lastEvent)
                }
        }

        return event, nil
}

TriggerFactor <- '(' cnt:TriggerG ')' {
        return cnt, nil
} / ce:TriggerEvent {
        return ce, nil
}

TriggerEvent <- IntervalDesc / TriggerFilter

TriggerOperators <- "||" / "&&"

IntervalDesc <- _ "interval" _ "=" _ val:Number unit:("s" / "m" / "h") {
        v := val.(int64)
        u, _ := utils.TryString(unit)

        var interval time.Duration

        switch u {
        case "s":
                interval = time.Duration(v) * time.Second
        case "m":
                interval = time.Duration(60 * v) * time.Second
        case "h":
                interval = time.Duration(60 * 60 * v) * time.Second
        default:
                return nil, errors.New("Non-supported time unit.")
        }

        return poll.NewTimerEvent(interval), nil
}

TriggerFilter <- filt:FilterMulti {
        if f, ok := filt.(Filter); ok {
                eventFilter := func(m map[string]interface{}) bool {
                        out, _ := f(m)
                        return out
                }
                return poll.NewFilterEvent(eventFilter), nil
        }
        return nil, errors.New("Could not parse filter!!")
}

